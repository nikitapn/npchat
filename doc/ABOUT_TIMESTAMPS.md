  // ===== BENEFITS OF AUTO TIMESTAMPS =====
  // ✅ Database-level consistency - no clock skew issues
  // ✅ Automatic handling - no manual timestamp management
  // ✅ Prevents timestamp manipulation by clients
  // ✅ Consistent timezone handling
  // ✅ Atomic operations - timestamp created at exact insert time

  // ===== CURRENT MANUAL APPROACH =====
  // ❌ Client-side timestamp generation
  // ❌ Potential clock skew between client and server
  // ❌ Possible timestamp manipulation
  // ❌ Race conditions if multiple clients insert simultaneously
  // ❌ Requires application code to manage timestamps

  // ===== MIGRATION CONSIDERATIONS =====
  // 1. Update table schema with DEFAULT clause
  // 2. Modify INSERT statement to exclude timestamp column
  // 3. Update parameter binding (remove timestamp parameter)
  // 4. Consider data migration if existing timestamps need conversion
  // 5. Update SELECT queries if timestamp format changes

  // ===== AUTO TIMESTAMP OPTIONS =====

  // Option 1: Unix timestamp (recommended for your current setup)
  // INSERT INTO messages (chat_id, sender_id, content, attachment_id)
  // VALUES (?, ?, ?, ?)
  // timestamp will be auto-generated by SQLite

  // Option 2: ISO datetime string
  // INSERT INTO messages (chat_id, sender_id, content, attachment_id)
  // VALUES (?, ?, ?, ?)
  // timestamp will be auto-generated as '2025-09-01 12:34:56'

  // Option 3: Custom precision
  // INSERT INTO messages (chat_id, sender_id, content, attachment_id)
  // VALUES (?, ?, ?, ?)
  // timestamp will be auto-generated with milliseconds


  // ===== STEP-BY-STEP MIGRATION TO AUTO TIMESTAMPS =====

  // Step 1: Update table schema (run this SQL)
  // ALTER TABLE messages ADD COLUMN new_timestamp INTEGER DEFAULT (strftime('%s', 'now'));
  // UPDATE messages SET new_timestamp = timestamp WHERE new_timestamp IS NULL;
  // ALTER TABLE messages DROP COLUMN timestamp;
  // ALTER TABLE messages RENAME COLUMN new_timestamp TO timestamp;

  // Step 2: Update INSERT statement
  // OLD: "INSERT INTO messages (chat_id, sender_id, content, timestamp, attachment_id) VALUES (?, ?, ?, ?, ?)"
  // NEW: "INSERT INTO messages (chat_id, sender_id, content, attachment_id) VALUES (?, ?, ?, ?)"

  // Step 3: Update parameter binding in sendMessage()
  // OLD: sqlite3_bind_int64(insert_message_stmt_, 4, message.timestamp);
  // NEW: Remove this line entirely

  // Step 4: Update attachment parameter index
  // OLD: sqlite3_bind_int(insert_message_stmt_, 5, attachment_id);
  // NEW: sqlite3_bind_int(insert_message_stmt_, 4, attachment_id);

  // ===== TESTING THE MIGRATION =====
  // 1. Backup your database first!
  // 2. Test on a copy of your data
  // 3. Verify timestamps are still working correctly
  // 4. Check that new messages get auto-generated timestamps
  // 5. Ensure existing message timestamps are preserved

  // Current implementation (manual timestamp)
  // insert_message_stmt_ = db_->prepareStatement(
  //   "INSERT INTO messages (chat_id, sender_id, content, timestamp, attachment_id) VALUES (?, ?, ?, ?, ?)");

  // ===== ALTERNATIVE APPROACHES FOR AUTO TIMESTAMPS =====

  // Option 1: Use a trigger (most reliable)
  // CREATE TRIGGER messages_timestamp_trigger
  //   AFTER INSERT ON messages
  //   WHEN NEW.timestamp IS NULL
  // BEGIN
  //   UPDATE messages SET timestamp = strftime('%s', 'now') WHERE id = NEW.id;
  // END;

  // Option 2: Use a view with computed timestamp (read-only)
  // CREATE VIEW messages_with_timestamp AS
  // SELECT id, chat_id, sender_id, content,
  //        COALESCE(timestamp, strftime('%s', 'now')) as timestamp,
  //        attachment_id
  // FROM messages;

  // Option 3: Application-level default (current approach but improved)
  // Always provide timestamp from application, but use database time

  // Option 4: Use INTEGER PRIMARY KEY (rowid) timing
  // SQLite's rowid is roughly chronological, can be used as timestamp proxy

  // ===== RECOMMENDED: TRIGGER APPROACH =====
  // This is the most reliable way to get auto timestamps in SQLite

  // ===== WORKING SOLUTION: SQLite Triggers =====

  // Step 1: Create the trigger in your database schema
  // Run this SQL once during database initialization:

  /*
  -- Create trigger for auto timestamps
  CREATE TRIGGER IF NOT EXISTS messages_auto_timestamp
    BEFORE INSERT ON messages
    FOR EACH ROW
    WHEN NEW.timestamp IS NULL
  BEGIN
    UPDATE messages SET timestamp = strftime('%s', 'now')
      WHERE id = NEW.id;
  END;
  */

  // Alternative trigger approach (simpler):
  /*
  CREATE TRIGGER IF NOT EXISTS messages_auto_timestamp
    BEFORE INSERT ON messages
    FOR EACH ROW
    WHEN NEW.timestamp IS NULL
  BEGIN
    SELECT RAISE(ABORT, 'Timestamp cannot be NULL');
  END;
  */

  // Step 2: Modify your INSERT to allow NULL timestamps
  // insert_message_stmt_ = db_->prepareStatement(
  //   "INSERT INTO messages (chat_id, sender_id, content, timestamp, attachment_id)
  //    VALUES (?, ?, ?, NULL, ?)");  // Pass NULL for timestamp

  // Step 3: Update your sendMessage() method
  // sqlite3_bind_null(insert_message_stmt_, 4);  // Instead of binding timestamp

  // ===== COMPLETE MIGRATION SCRIPT =====

  /*
  -- Migration script for existing database
  BEGIN TRANSACTION;

  -- 1. Add new timestamp column (without default)
  ALTER TABLE messages ADD COLUMN new_timestamp INTEGER;

  -- 2. Copy existing timestamps
  UPDATE messages SET new_timestamp = timestamp;

  -- 3. Set NULL timestamps to current time for any missing values
  UPDATE messages SET new_timestamp = strftime('%s', 'now')
    WHERE new_timestamp IS NULL;

  -- 4. Drop old column
  ALTER TABLE messages DROP COLUMN timestamp;

  -- 5. Rename new column
  ALTER TABLE messages RENAME COLUMN new_timestamp TO timestamp;

  -- 6. Create trigger for future inserts
  CREATE TRIGGER messages_auto_timestamp
    BEFORE INSERT ON messages
    FOR EACH ROW
    WHEN NEW.timestamp IS NULL
  BEGIN
    UPDATE messages SET timestamp = strftime('%s', 'now')
      WHERE id = NEW.id;
  END;

  COMMIT;
 